{
    "lesson-id": "lesson-10-complex-joins",
    "title": "Lesson 10",
    "subtitle": "Complex Join Logic",
    "lesson-order": 10,
    "key-topics": "Self joins, multi-condition joins, non-equijoins",
    "database-tables": [
        {
            "name": "Countries",
            "priority": 1
        },
        {
            "name": "Cities",
            "priority": 2
        },
        {
            "name": "People",
            "priority": 3
        }
    ],
    "exercise-tasks": [
        {
            "task-id": 10.1,
            "description": "Self-join the Cities table to find pairs of cities within the same country. Show the names of both cities.",
            "correct-query": "SELECT\n  c1.Name AS CityA,\n  c2.Name AS CityB\nFROM Cities c1\nJOIN Cities c2 ON c1.CountryID = c2.CountryID\n  AND c1.CityID <> c2.CityID",
            "verify-query": "SELECT c1.Name AS CityA, c2.Name AS CityB FROM Cities c1 JOIN Cities c2 ON c1.CountryID = c2.CountryID AND c1.CityID <> c2.CityID",
            "order-sensitive": false,
            "exercise-order": 1,
            "initial-query": "SELECT * FROM Cities",
            "large-query": false,
            "allow-dml": false,
            "create-tables": false,
            "preview-allowed": true,
            "chatgpt-prompt": "Explain why this SQL query correctly finds all pairs of cities within the same country using a self join. How does the condition c1.CityID <> c2.CityID prevent a city from pairing with itself? Why are aliases like c1 and c2 necessary for self joins? How does the ON clause combine the country condition with the inequality condition?\n\nCorrect query:\nSELECT\n  c1.CityName AS CityA,\n  c2.CityName AS CityB\nFROM Cities c1\nJOIN Cities c2 ON c1.CountryID = c2.CountryID\n  AND c1.CityID <> c2.CityID"
        },
        {
            "task-id": 10.2,
            "description": "Join Countries with Cities and People and filter to show people living in countries with a population strictly greater than 38,000,000. Show the person's name, the city name and the country population.",
            "correct-query": "SELECT\n  p.Name,\n  c.Name,\n  co.Population\nFROM People p\nJOIN Cities c ON p.CityID = c.CityID\nJOIN Countries co ON c.CountryID = co.CountryID\nWHERE c.population > 38000000",
            "verify-query": "SELECT p.Name, c.Name, co.Population FROM People p JOIN Cities c ON p.CityID = c.CityID JOIN Countries co ON c.CountryID = co.CountryID WHERE c.population > 38000000",
            "order-sensitive": false,
            "exercise-order": 2,
            "initial-query": "SELECT * FROM People",
            "large-query": false,
            "allow-dml": false,
            "create-tables": false,
            "preview-allowed": true,
            "chatgpt-prompt": "Explain why this SQL query correctly lists people living in cities with a population greater than 8,400,000, along with their city and country. How do multiple INNER JOINs combine People, Cities, and Countries? How does the WHERE clause filter the results based on population? Why is the order of joins important before applying the WHERE condition?\n\nCorrect query:\nSELECT\n  p.Name,\n  c.CityName,\n  co.CountryName\nFROM People p\nJOIN Cities c ON p.CityID = c.CityID\nJOIN Countries co ON c.CountryID = co.CountryID\nWHERE c.population > 8400000"
        }
    ]
}
