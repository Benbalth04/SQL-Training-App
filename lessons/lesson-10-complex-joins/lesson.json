{
    "lesson-id": "lesson-10-complex-joins",
    "title": "Lesson 10",
    "subtitle": "Complex Join Logic",
    "lesson-order": 10,
    "key-topics": "Self joins, multi-condition joins, non-equijoins",
    "database-tables": [
        {
            "name": "Countries",
            "priority": 1
        },
        {
            "name": "Cities",
            "priority": 2
        },
        {
            "name": "People",
            "priority": 3
        }
    ],
    "exercise-tasks": [
        {
            "task-id": 10.1,
            "description": "List each person and their manager using a self join on the People table.",
            "correct-query": "SELECT\n  p.Name AS Person,\n  m.Name AS Manager\nFROM People\nLEFT JOIN People m ON p.ManagerID = m.PersonID",
            "verify-query": "SELECT p.Name AS Person, m.Name AS Manager FROM People p LEFT JOIN People m ON p.ManagerID = m.PersonID",
            "order-sensitive": false,
            "exercise-order": 1,
            "initial-query": "SELECT * FROM People",
            "large-query": false,
            "allow-dml": false,
            "create-tables": false,
            "preview-allowed": true,
            "chatgpt-prompt": "Explain why this SQL query correctly lists each person alongside their manager using a self join. How does the LEFT JOIN differ from an INNER JOIN in this context? Why is the People table referenced twice with different aliases (p and m)? How does the ON clause ensure the correct manager is matched to each person?\n\nCorrect query:\nSELECT\n  p.Name AS Person,\n  m.Name AS Manager\nFROM People\nLEFT JOIN People m ON p.ManagerID = m.PersonID"
        },
        {
            "task-id": 10.2,
            "description": "Join Cities and Countries using two conditions: matching CountryID and matching Region.",
            "correct-query": "SELECT * FROM Cities c\nJOIN Countries co ON c.CountryID = co.CountryID\n  AND c.Region = co.Region",
            "verify-query": "SELECT * FROM Cities c JOIN Countries co ON c.CountryID = co.CountryID AND c.Region = co.Region",
            "order-sensitive": false,
            "exercise-order": 2,
            "initial-query": "SELECT * FROM Cities",
            "large-query": false,
            "allow-dml": false,
            "create-tables": false,
            "preview-allowed": true,
            "chatgpt-prompt": "Explain why this SQL query correctly joins Cities and Countries using two conditions. How does specifying multiple conditions in the ON clause work? Why are table aliases like c and co useful? What would happen if only one of the conditions (CountryID or Region) was used?\n\nCorrect query:\nSELECT * FROM Cities c\nJOIN Countries co ON c.CountryID = co.CountryID\n  AND c.Region = co.Region"
        },
        {
            "task-id": 10.3,
            "description": "Perform a non-equijoin matching People.Age to a range defined by Countries (MinAge to MaxAge).",
            "correct-query": "SELECT\n  p.Name,\n  c.CountryName\nFROM People p\nJOIN Countries c ON p.Age BETWEEN c.MinAge AND c.MaxAge",
            "verify-query": "SELECT p.Name, c.CountryName FROM People p JOIN Countries c ON p.Age BETWEEN c.MinAge AND c.MaxAge",
            "order-sensitive": false,
            "exercise-order": 3,
            "initial-query": "SELECT * FROM People",
            "large-query": false,
            "allow-dml": false,
            "create-tables": false,
            "preview-allowed": true,
            "chatgpt-prompt": "Explain why this SQL query correctly matches each person to a country based on age ranges using a non-equijoin. How does the BETWEEN operator work in the ON clause? Why is this different from a standard equality join? How do the SELECT columns determine the output of the join?\n\nCorrect query:\nSELECT\n  p.Name,\n  c.CountryName\nFROM People p\nJOIN Countries c ON p.Age BETWEEN c.MinAge AND c.MaxAge"
        },
        {
            "task-id": 10.4,
            "description": "Self-join the Cities table to find pairs of cities within the same country.",
            "correct-query": "SELECT\n  c1.CityName AS CityA,\n  c2.CityName AS CityB\nFROM Cities c1\nJOIN Cities c2 ON c1.CountryID = c2.CountryID\n  AND c1.CityID <> c2.CityID",
            "verify-query": "SELECT c1.CityName AS CityA, c2.CityName AS CityB FROM Cities c1 JOIN Cities c2 ON c1.CountryID = c2.CountryID AND c1.CityID <> c2.CityID",
            "order-sensitive": false,
            "exercise-order": 4,
            "initial-query": "SELECT * FROM Cities",
            "large-query": false,
            "allow-dml": false,
            "create-tables": false,
            "preview-allowed": true,
            "chatgpt-prompt": "Explain why this SQL query correctly finds all pairs of cities within the same country using a self join. How does the condition c1.CityID <> c2.CityID prevent a city from pairing with itself? Why are aliases like c1 and c2 necessary for self joins? How does the ON clause combine the country condition with the inequality condition?\n\nCorrect query:\nSELECT\n  c1.CityName AS CityA,\n  c2.CityName AS CityB\nFROM Cities c1\nJOIN Cities c2 ON c1.CountryID = c2.CountryID\n  AND c1.CityID <> c2.CityID"
        },
        {
            "task-id": 10.5,
            "description": "Join Countries with Cities and People and filter to show people living in cities with a population strictly greater than 8,400,000",
            "correct-query": "SELECT\n  p.Name,\n  c.CityName,\n  co.CountryName\nFROM People p\nJOIN Cities c ON p.CityID = c.CityID\nJOIN Countries co ON c.CountryID = co.CountryID\nWHERE c.population > 8400000",
            "verify-query": "SELECT p.Name, c.CityName, co.CountryName FROM People p JOIN Cities c ON p.CityID = c.CityID JOIN Countries co ON c.CountryID = co.CountryID WHERE c.population > 8400000",
            "order-sensitive": false,
            "exercise-order": 5,
            "initial-query": "SELECT * FROM People",
            "large-query": false,
            "allow-dml": false,
            "create-tables": false,
            "preview-allowed": true,
            "chatgpt-prompt": "Explain why this SQL query correctly lists people living in cities with a population greater than 8,400,000, along with their city and country. How do multiple INNER JOINs combine People, Cities, and Countries? How does the WHERE clause filter the results based on population? Why is the order of joins important before applying the WHERE condition?\n\nCorrect query:\nSELECT\n  p.Name,\n  c.CityName,\n  co.CountryName\nFROM People p\nJOIN Cities c ON p.CityID = c.CityID\nJOIN Countries co ON c.CountryID = co.CountryID\nWHERE c.population > 8400000"
        }
    ]
}
